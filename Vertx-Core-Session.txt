				Eclipse Vert.x

What is Eclipse Vert.x ?

    Eclipse Vert.x is a tool-kit for building "reactive applications" on the JVM.

Eclipse Vert.x :
    Vert.X was released under Eclipse foundation open source license

Frameworks / libs/tookit:
  toolkit is nothing but you can embed into any exiting applications written by using language or framework or lib.

reactive Applications:
  Building declarative, non blocking, async programming using functional programming principles such as pure functions, immutablity, higher order function.

IO internals:
..............


Why Vert.x? Why Vert.x was created?


10k = if a web server is able to handle 10thousand connections per ms/sc, that web server is good.

cost: 
  machine
  maintaince cost
How to reduce this cost?

 c10k problems state that how to improve exisiting web server...

Problems:
 1.threads
   per client 1 thread - 100 client 100 threads
 
 drawbacks
   - each thread when you create it takes some memory - 2mb   
   - after thread thread creation, we have to manage life cycle of thread - cpu

 in linux introduced new alogorthims
   call ctx switch 
  if any thread is paused more time  - move out of memory - thread pause , thread resume
  
Linux system calls for building non blocking io apps
......................................................
1.select + read 
2.poll ->
3.epoll -> it is optimized poll api 


Who implemented first non blocking webserver.

nginx - first non blocking web server

node.js - second programmable non blocking applications written

.....................................................................................
 		Building block of Vertx-Vertx Architecture
.....................................................................................

NonBlocking io:
...............


IO:

Hardware devices typically provide the ability to input data into the computer or output data from the computer.

To simplify the ability to support a variety of hardware devices, standardized application programming interfaces (API) are used.

Application programs use the "System Call API" to request one of a finite set of preset I/O requests from the Operating System.

The Operating System uses algorithms for processing the request that are device independent.

The Operating System uses another API to request data from the device driver.

The device driver is third party software that knows how to interact with the specific device to perform the I/O.

Sometimes we have a layering of device drivers where one device driver will call on another device driver to facilitate the I/O.

 An example of this is when devices are connected to a USB port. The driver for the device will make use of the USB device driver to facilitate passing data to and from the device.

File Descriptor:
..................

File descriptor or file descriptor table is nothing but , it is "c" program which has all information about  io opertaions.

Fd is bridge between application runtime/process and io devices.


Blocking io code in java:
........................

blocking network socket app.


import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class BlockingEco {
    public static void main(String[] args) throws Throwable {
        //this api interally communicates network interface card
        ServerSocket server = new ServerSocket();
        server.bind(new InetSocketAddress(3000));
        System.out.println("Blocking Socket : listening for new Request");
        while (true) {   // <1>
            Socket socket = server.accept();
            //each incomming request(socket request) allocate in a separate thread
            new Thread(clientHandler(socket)).start();
        }
    }

    private static Runnable clientHandler(Socket socket) {
        return () -> {

            try (
                    BufferedReader reader = new BufferedReader(
                            new InputStreamReader(socket.getInputStream()));
                    PrintWriter writer = new PrintWriter(
                            new OutputStreamWriter(socket.getOutputStream()))) {
                String line = "";
                while (!"/quit".equals(line)) {
                    line = reader.readLine();      // <2>
                    System.out.println("~ " + line);
                    writer.write(line + "\n");  // <3>
                    writer.flush();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
    }

}

Why not blocking?

Blocking APIs waste resources, increase costs


The main problem with the code above ,is that it allocates a new thread for each incoming connection(request) and threads are anything but cheap resources. 

A thread needs memory, and the more threads you have, the more you put pressure on the operating system kernel scheduler, as it needs to give CPU time to the thread

 Input/output operations such as readLine and write may block the thread, meaning that it is being parked by the operating system. This happens for two reasons:

A read operation may be waiting for data to arrive from the network.
A write operation may have to wait for buffers to be drained if they are full from a previous write operation

NonBlocking io  = IO Multiplxing (Nonblocking io,SIGIO,POSX_IO FUNCTIONS)

Today there are two io programming models = blocking and io multiplexing(Non,async)

Generally all webservers work based on "Request per thread Model".

2000,C10K - concurrently handling ten thousand connections.

2000, Linux operating system introduced a new api for io operations which does not block thread - "select"	

non blocking io operation: 

1.select + read - first non blocking io operation introduced in linux operating system.

2.poll - second non blocking io operation api introduced in linux. the difference is 
         poll pushing data from kernal to application process rather pulling data          from  kernal table.

3.Epoll -  this modern non blocking io api introduced in linux....

Other Operating system non blocking abstractions:

EPoll -Linux
IOCP - Windows
kqueue -mac and other open bsd versions.
.....................................................................................
java and non blocking:
......................

Does java support non blocking apis?

No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"-NONBlocking IO.

NIO version: non blocking version

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Pattern;

public class AsynchronousEcho {

  public static void main(String[] args) throws IOException {
    Selector selector = Selector.open();

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(3000));
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
      selector.select();
      Iterator<SelectionKey> it = selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key = it.next();
        if (key.isAcceptable()) {
          newConnection(selector, key);
        } else if (key.isReadable()) {
          echo(key);
        } else if (key.isWritable()) {
          continueEcho(selector, key);
        }
        it.remove();
      }
    }
  }

  private static class Context {
    private final ByteBuffer nioBuffer = ByteBuffer.allocate(512);
    private String currentLine = "";
    private boolean terminating = false;
  }

  private static final HashMap<SocketChannel, Context> contexts = new HashMap<>();

  private static void newConnection(Selector selector, SelectionKey key) throws IOException {
    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
    SocketChannel socketChannel = serverSocketChannel.accept();
    socketChannel
      .configureBlocking(false)
      .register(selector, SelectionKey.OP_READ);
    contexts.put(socketChannel, new Context());
  }

  private static final Pattern QUIT = Pattern.compile("(\\r)?(\\n)?/quit$");

  private static void echo(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      socketChannel.read(context.nioBuffer);
      context.nioBuffer.flip();
      context.currentLine = context.currentLine + Charset.defaultCharset().decode(context.nioBuffer);
      if (QUIT.matcher(context.currentLine).find()) {
        context.terminating = true;
      } else if (context.currentLine.length() > 16) {
        context.currentLine = context.currentLine.substring(8);
      }
      context.nioBuffer.flip();
      int count = socketChannel.write(context.nioBuffer);
      if (count < context.nioBuffer.limit()) {
        key.cancel();
        socketChannel.register(key.selector(), SelectionKey.OP_WRITE);
      } else {
        context.nioBuffer.clear();
        if (context.terminating) {
          cleanup(socketChannel);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }

  private static void cleanup(SocketChannel socketChannel) throws IOException {
    socketChannel.close();
    contexts.remove(socketChannel);
  }

  private static void continueEcho(Selector selector, SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      int remainingBytes = context.nioBuffer.limit() - context.nioBuffer.position();
      int count = socketChannel.write(context.nioBuffer);
      if (count == remainingBytes) {
        context.nioBuffer.clear();
        key.cancel();
        if (context.terminating) {
          cleanup(socketChannel);
        } else {
          socketChannel.register(selector, SelectionKey.OP_READ);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }
}
Problmes with NIO :

It is also important to note that like most JDK APIs, java.nio focuses solely on what it does (here, I/O APIs).
 
->It does not provide higher-level protocol-specific helpers, like for writing HTTP clients and servers.
 
->Also, java.nio does not prescribe a threading model, which is still important to properly utilize CPU 
cores, handle asynchronous I/O events, and articulate the application processing logic.

->This is why, in practice, developers rarely deal with Java NIO. 
.......................................................................................................

Networking libraries like Netty and Apache Mina solve the shortcomings of Java NIO


NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns- The first Reactor Model on jvm.

        	     Netty Application
		             |
          	         nettycore
			     |
			    nio
			     |
		            jvm

Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library

		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Vertx:

Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM.
 initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

			
			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


Objective of VertX:
   
    100% non blocking applications on jvm.
.....................................................................................
NonBlocking IO Apis


                     NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
            (vertx-core) - Vertx-web Vertx-webclient
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
	            	|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				                         |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

/////////////////////////////////////////////////////////////////////////////////////

Vertx Runtime:

Vertx run time is powered by non blocking io arch

Vertx uses event loops
 -event loops are used to process events which are dispatched by kernal.
 -Event loops are just threads to process incoming events from kernal

Event :

  collection of event and data
  How to read data?
    you need handler- callback functions


Vertx uses multi core event loop threads where as node js has only one event loop thread.

Vertx uses per cpu core - 2 event loop, lets say i have 12 cores - 12 *2 =24 event loops.
....................................................................................
	
	Lets enter into vertx app; how to build non blocking and async apps:
.....................................................................................

vertx Programming pattern:
  Functional style

Project setup:
..............
-Vertx Project setup
   -Maven Project
   -Gradle Project

1.plain maven project, add vertx depedencies,You can use template entry method provided by vertx .

2.Vertx Starter project

3.Vertx maven cli project


.................................................................................
			 How to create vertx cli project..

https://start.vertx.io/

Vertx application can be small to big enterprise microservice application.

Like spring , starts with spring-core , after that ,spring-mvc,spring-data....(modules)

Vertx also begins modules

vertx-core ,vertx-web,vertx-data..............etc...

vertx-core:

How to run vertx app?

Every Vertx apps will have entry point, configured in pom.xml

 <main.verticle>com.amex.MainVerticle</main.verticle>
 <launcher.class>io.vertx.core.Launcher</launcher.class>

How to run vertx apps?

1.compile the code and execute - dev mode.

mvnw clean compile exec:java

[INFO] Scanning for projects...
[INFO] 
[INFO] -----------------------< com.amex:vertxcoreapp >------------------------
[INFO] Building vertxcoreapp 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ vertxcoreapp ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ vertxcoreapp ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory E:\session\AMex\2023\vertxcoreapp\src\main\resources
[INFO]                                                                                         
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ vertxcoreapp ---            
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to E:\session\AMex\2023\vertxcoreapp\target\classes
[INFO] 
[INFO] --- exec-maven-plugin:3.0.0:java (default-cli) @ vertxcoreapp ---
HTTP server started on port 8888
Oct 16, 2023 2:22:56 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle

By default vertx offers some Webservice which is running in port 8888

http://localhost:8888/

2.Creating production apps -deployment 

mvnw clean package 

 This command gives two jars.
  
 Regular jar   - jar which has separate dependency - application has one jar , libs                  has another jar
 fat jar -  everything in one jar

How to run ?

java -jar target/vertxcoreapp-1.0.0-SNAPSHOT-fat.jar
.....................................................................................
Vert.x Learning Path:
.....................
1.Vert.x core
2.Vert.x Web apps - RESTFull API
3.Vert.x Reactive Programming - Using Rxjava or SmallRye Mutiny
4.Vert.x Database Programming
5.Microservices features and implementation


.....................................................................................
				Vert.x Core
.....................................................................................
			   vertx Core concepts
.....................................................................................

Core Vertx Concepts:
....................

1.Vertx Instance , so Called "Vertx Engine". === Spring Container
2.Verticles ; so called an Object through which you can create apps.

Vertx Engine is a java class, represented as interface in the io.vertx.core package

io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.

To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler)

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles


In order to write vertx app, we have two styles

1.Verticle based
2.With out Verticle

Verticle based is mostly recommened incase if you write independant vertx apps
Without Verticle itself you can write vertx app, it is mostly usefull if you embed vertx feature into some other apps like spring.

Demo: without Verticle:
.......................
package com.amex.withoutverticle;

import io.vertx.core.Vertx;

public class HelloVertx {
  public static void main(String[] args) {
    //vertx engine ready
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx.getClass().getName());
    //write simple web server
    vertx.createHttpServer().requestHandler(req->{
       req.response().end("Hello Vertx");
    }).listen(8080);
  }
}

.....................................................................................

Vertx modules:
...............
vertx-core
vertx-web
vertx-data
vertx-microservices
etc...

Verticles
Threading modles
callbacks
Promises
Futures

Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance(Engine).

What is deployment?

The action of bringing "resources" into effective action

In vertx, Brining Resources ready  for computation.

Resources:
 -Thread creation /allocation
 -binding an object with that thread
 -Register all event handlers in case of event driven programming
 -Allocate memory if required for data/other 
 -Ensures that other depenendant resources are ready.

-It is based on design pattern called "Actor-like Model"
-Verticles are bound to "Event loop" , are processed by event loop threads.

Verticle is interface which provides life cycle methods 
  -init   - called when verticle being initalized
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment


if you are writing any verticle class, you cant use "Verticle" Interface directly.

Vertx provides an implementation abstract class called "AbstractVerticle" class.


io.vertx.core.AbstractVerticle

Reactive Implementation based:
io.vertx.rxjava3.core.AbstractVerticle
io.vertx.rxjava.core.AbstractVerticle
io.vertx.reactivex.core.AbstractVerticle


How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.


eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}

package com.mycom;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;

public class HelloWorldVerticle extends AbstractVerticle {
  //override life cycle method
  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("Init is called");
  }

  //whenever we deploy the verticle on vertx engine these methods are called auotmatically
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println("Start is called");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Stop is called");
  }
}
....................................................................................	
			 Ways to Deploy verticles
....................................................................................

Deploying single verticle

1.Via pom.xml
<main.verticle>com.amex.MainVerticle</main.verticle>
    <launcher.class>io.vertx.core.Launcher</launcher.class>

mvnw clean compile exec:java

..................................................................................

Deploying many verticles.

1.within Main verticle and deployother Verticles
2.write simple java class and through which we can deploy
3.Vertx Provides  a runner/Lanucher class through which also you can deploy.


1.within Main verticle and deploy other Verticles
			
Main verticle is configured in pom.xml


1.Via pom.xml
<main.verticle>com.amex.MainVerticle</main.verticle>
<launcher.class>io.vertx.core.Launcher</launcher.class>

mvnw clean compile exec:java

package com.amex;

package com.amex;

import io.vertx.core.AbstractVerticle;
//import io.vertx.core.Vertx;

public class MainVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Main Vertical started");
//    Vertx vertx = Vertx.vertx();
   // vertx.deployVerticle("com.amex.HelloWorldVerticle");
   // vertx.deployVerticle(HelloWorldVerticle.class.getName());
      vertx.deployVerticle(new HelloWorldVerticle());

  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Main Vertical stopped");

  }
}


package com.amex;

import io.vertx.core.AbstractVerticle;

public class HelloWorldVerticle extends AbstractVerticle {
  //called after this verticle deployed on vertx engine
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Helloworld Verticle is started");
  }

  //called after undeployed from the vert engine
  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("HelloWorld  Vertical stopped");

  }


}
.....................................................................................

Way 2: From plain java code how to deploy verticles.

package com.amex;

import io.vertx.core.Vertx;

public class DeployerMain {
  public static void main(String[] args) {
      //you can deploy
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new MainVerticle());
  }
}
This code will not call life cycle method like stops, mostly not this pattern not recommended.

Way 3: Using explcit Lanucher /Runner class without using pom.xml configuration.

package com.amex;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;

public class LanucherDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run",LanucherDeployer.class.getName());
  }

  @Override
  public void start() throws Exception {
    super.start();
      vertx.deployVerticle(MainVerticle.class.getName());
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Launcher stop");
  }
}
.....................................................................................
				Vertx Coding Style
.....................................................................................

Patterns to write non blocking apps

1.callback style -traditional way
2.Reactive style -Streaming pattern

In order to write non blocking apps,
  the os should support non blocking infrastructure - epoll,kqueue,iocp.
  The pl and frameworks should give apis to leverlage non blocking


Non blocking apis provided vertx.
1.timer - vertx.setPeriodic
2.http -vertx.createHttpServer()
3.fs
4.socket
5.database
etc.......



Reactive and nonblocking :

non-blocking
  how to use min no threads, using event driven model for io

reactive
   how to write code declarativly to transfer data from one app/ to another app -straming
   while writing reactive programing you can use "non blocking infrastructure"

 min -threads,declarative,

vertx - non blocking + reactive => fully nonblocking reactive app

Callback/Listener Style:
1.Future
2.Promises


if you come from java script && node.js background,you know the concept called "Callback function" - callback function is other wise called as "listener function" or "handler function".

Handler Function /Callback function/Listener function:
.......................................................
1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop thread starts processing event by assinging a handler function.

What is handler function/callback function/listener function for?

 "To handle async success /failure result"
     "The result of async Operation could be either success or failure".

io.vertx.Future:

-it is interface used to handle async success/failure results.
-vertx uses Future(Object) to represent "Asynchronous" Results
-Future is like transport object to transport data between caller and callee in async  manner

Caller -------Future-----Callee


What type of data Future can carry?

-Success--------|
                  ---->Future -----Verticle----Thread---bound with event loop--events
-Failure--------|

AsynResult<T>:

Encapsulates the result of an asynchronous operation.

Object which has either success data or failure data.

If it failed then the cause of the failure is available with cause().

If it succeeded then the actual result is available with result()
...................................................................................

Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation

Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate  inside this api.

Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
3.onSuccess
5.onFailure



AsyncResult interface apis

 -result() - get the success result sent by Future
 -cause()   -get the failure result sent by Future
 -succeed() -test whether it was success or failure
 -failed()  -test whether it was failure or success
....................................................................................
			 Getting Future Usage code
....................................................................................

How to create Future Object and returns response?

Caller
   who calls api
Callee
   who provides api which returns "Future" with either success or failure.

Future may return data or may not: Empty Future:
package com.amex.futures;

import io.vertx.core.*;

public class FutureDemoVertcle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureDemoVertcle.class.getName());
  }

  //empty Future
  public Future<Void> getEmptyFuture(){
      //Create FutureObject using Anoymous innerclass pattern
//   return   Future.future(new Handler<Promise<Void>>() {
//       @Override
//       public void handle(Promise<Void> event) {
//            event.complete();
//       }
//     });
    //Create Future Object using lambda pattern: it is highly recommend
    return   Future.future(event->{
        event.complete(); //complete method is empty meaning that no data is returned
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    //callee :anonymous inner class
//    getEmptyFuture().onComplete(new Handler<AsyncResult<Void>>() {
//      @Override
//      public void handle(AsyncResult<Void> asyncResult) {
//          if(asyncResult.succeeded()){
//            System.out.println("Empty Future returned");
//            asyncResult.result();
//          }
//      }
//    });
    getEmptyFuture().onComplete(asyncResult -> {
      if(asyncResult.succeeded()){
        System.out.println("Empty Future is returned");
      }
    });

  }

  @Override
  public void stop() throws Exception {
    super.stop();
  }
}
.....................................................................................

Future with Data,Error,Both
............................
package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;


public class FutureWithDataVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureWithDataVerticle.class.getName());
  }

  //Data can be anything: string,numbers,objects, Json
  public Future<String> getHelloMessage(){
      return  Future.future(future->{
          future.complete("Hello Future");
      });
  }
  //How to return error
  public Future<String> getError(){
    return  Future.future(future->{
        future.fail("Something went wrong");
    });
  }

  //biz logic with error or success

  public Future<String> login(String userName,String password){
       if(userName.equals("admin") && password.equals("admin")){
            return  Future.future(future->{
                 future.complete("Login Success");
            });
       }
       return  Future.future(future->{
           future.fail("Login is failed");
       });
  }


  @Override
  public void start() throws Exception {
    super.start();
    //scuccess
   getHelloMessage().onComplete(event->{
      if(event.succeeded()){
        System.out.println(event.result());
      }else{
        System.out.println(event.cause().getMessage());
      }
   });
   //error
    getError().onComplete(event->{
       if(event.failed()){
         System.out.println(event.cause());
       }
    });
    //login with success
    login("admin","admin").onComplete(event->{
        if(event.succeeded()){
          System.out.println(event.result());
        }else {
          System.out.println(event.cause());
        }
    });

    login("foo","bar").onComplete(event->{
      if(event.succeeded()){
        System.out.println(event.result());
      }else {
        System.out.println(event.cause());
      }
    });


  }

  @Override
  public void stop() throws Exception {
    super.stop();
  }
}
....................................................................................
Shortcuts for Listener Code;
.............................

Listener api Which returns Future.

Syntax:
someApi().onComplete(Handler<AsynResult>)
someApi().onSuccess(res->{});
someApi().onError(err->{});
someApi().onSuccess(res->{}).onError(err->{});
someApi().onSuccess(System.out::println).onError(System.out::println);

package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class FutureListenerSyntaxVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run",FutureListenerSyntaxVerticle.class.getName());
  }

  public Future<String> getMessage(){
    return  Future.future(future->{
         future.complete("Hello");
    });
  }
  public Future<String> getError(){
    return  Future.future(future->{
      future.fail("");
    });
  }
  public Future<String> login(String userName,String password){
    if(userName.equals("admin") && password.equals("admin")){
      return  Future.future(future->{
        future.complete("Login Success");
      });
    }
    return  Future.future(future->{
      future.fail("Login is failed");
    });
  }
  @Override
  public void start() throws Exception {
    super.start();
    getMessage().onComplete(event->{
         if(event.succeeded()){
           System.out.println(event.result());
         }
    });
    //shortcut with lambda
    getMessage().onSuccess(res->{
      System.out.println(res);
    });
    //shortcut with methodReference
    getMessage().onSuccess(System.out::println);

    //errro
    getError().onFailure(err->{
      System.out.println(err);
    });
    getError().onFailure(System.err::println);

    //both success and failure
    login("admin","admin").onComplete(event->{
      if(event.succeeded()){
        System.out.println(event.result());
      }else {
        System.out.println(event.cause());
      }
    });
    login("admin","admin")
      .onSuccess(System.out::println)
      .onFailure(System.err::println);
  }
}
.....................................................................................
			 Callback Chaining
.....................................................................................

In Sequential Programming/sync Programming, the flow of the program like below


//jdbc workflow
Connection con = DriverManger.getConnection();
Statement st = con.createStatement();
ResultSet rows =st.executeQuery("select * from orders")
while(rows.next()){
  System.out.println(rows.getInt(0)));
}
Here flow will go one after another.

What if the same task can be done in functional programming or async way:Vertx.

Functional way of writing sequential work flow.
   Nested Callbacks/callback chaining/functional Style.


Handler function is called as callback function.

"The output of one callback is input to the another callback , nested callback.

cb1
   ---cb2
       |
        ------
       cb3
	|
	|	
	---------
	|
	|
	cb4 
	 |
	 |
	 --------
	  |
	  cbN
	    |
	    process the result.

Use Case:
 getUser
 login
 showDashard

 if getUser success
        |
	login- success
          |
	  showDashboard

 if getUser failed
        |
	login-  failed
          |
	  showDashboard -failed

 catch -
....................................................................................

Creating Future Object and Return:

Ways :
1.Future.future(fu->{})
  public Future<String> login(String userName,String password){
       if(userName.equals("admin") && password.equals("admin")){
            return  Future.future(future->{
                 future.complete("Login Success");
            });
       }
       return  Future.future(future->{
           future.fail("Login is failed");
       });
  }
2.Future
  Future.succeededFuture | failedFuture

  public Future<User> getUser(){
      User user = new User("admin","admin");
      if(user!=null){
        return  Future.succeededFuture(user);
      }else{
        return Future.failedFuture("User Not Found");
      }
  }

Callback Chaining:
.................
package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackVerticle.class.getName());
  }

  //getUser
  public Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
    //user = null; Testing for failures
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  public Future<String> login(User user) {
    System.out.println("Login is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("Login is success");
    } else {
      return Future.failedFuture("Login is failed");
    }
  }

  public Future<String> showDashboard(String status) {
    System.out.println("ShowDashboard is called");
    if (status.equals("Login is success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Sorry Try Again!");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(userHandler -> {
      if (userHandler.failed()) {
        System.out.println(userHandler.cause().getMessage());
      } else {
        User user = userHandler.result();
        login(user).onComplete(loginHandler -> {
          if (loginHandler.failed()) {
            System.out.println(loginHandler.cause().getMessage());
          } else {
            showDashboard(loginHandler.result()).onComplete(dashboardHandler -> {
              if (dashboardHandler.failed()) {
                System.out.println(dashboardHandler.cause().getMessage());
              } else {
                System.out.println(dashboardHandler.result());
              }
            });
          }
        });
      }
    });
  }

  @Override
  public void stop() throws Exception {
    super.stop();
  }
}
.....................................................................................
....................................................................................
			 Calback Hell
............................................................................

    getUser().onComplete(userHandler -> {
      if (userHandler.failed()) {
        System.out.println(userHandler.cause().getMessage());
      } else {
        User user = userHandler.result();
        // System.out.println(user.getUserName() + " " + user.getPassword());
        //call login
        login(user.getUserName(), user.getPassword()).onComplete(loginHandler -> {
          if (loginHandler.failed()) {
            System.out.println(loginHandler.cause().getMessage());
          } else {
            //System.out.println(loginHandler.result());
            showDashboard(loginHandler.result()).onComplete(dashboardHandler -> {
              if (dashboardHandler.failed()) {
                System.out.println(dashboardHandler.cause());
              } else {
                System.out.println(dashboardHandler.result());
              }
            });
          }
        });
      }
    });


Look at the above code, ask your self

1.is it easy to understand
2.is it easy to scale
3.is it easy to maintain.

No!
This is called callback hell, the callback hell is way of writing complex callback based programming.

Can we escape from the callback hell problem, or how to write better callback based programming.

Yes!

Solutions For Callback Hell
.................................

Solution 1:
..........
  private void giveSolutionOne() {
    //Using onSuccess and OnSuccess
    getUser()
      .onSuccess(user -> {
        login(user).onSuccess(status -> {
          showDashboard(status).onSuccess(dashboard -> {
          }).onFailure(dashboardErr -> {
            System.out.println(dashboardErr.getMessage());
          });
        }).onFailure(loginErr -> {
          System.out.println(loginErr.getMessage());
        });
      }).onFailure(err -> {
        System.out.println(err.getMessage());
      });
  }

Solution 2:
  private void giveSolutionTwo() {
    getUser()
      .compose(user -> {
        return login(user);
      })
      .compose(status -> {
        return showDashboard(status);
      })
      .onSuccess(res -> System.out.println(res))
      .onFailure(err -> System.out.println(err));
  }

Solution 2.1: code refactoring using functional programming concepts
if function has no any code only return statement,then we can remove {} and return statement -  lambda refactoring.

  private void giveSolutionTwo() {
    getUser()
      .compose(user -> login(user))
      .compose(status -> showDashboard(status))
      .onSuccess(res -> System.out.println(res))
      .onFailure(err -> System.out.println(err));
  }

Solution 2.2: Using Compose , and using java 8 method reference, instead of lambda syntax, we use Method reference.

  private void giveSolutionTwo() {
    getUser()
      .compose(this::login)
      .compose(this::showDashboard)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
     }

Demo:
package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class CallbackHellSolutionVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackHellSolutionVerticle.class.getName());
  }

  //getUser
  public Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
    //user = null; Testing for failures
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  public Future<String> login(User user) {
    System.out.println("Login is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("Login is success");
    } else {
      return Future.failedFuture("Login is failed");
    }
  }

  private Future<String> showDashboard(String status) {
    System.out.println("ShowDashboard is called");
    if (status.equals("Login is success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Sorry Try Again!");
    }
  }

  private void giveSolutionOne() {
    //Using onSuccess and OnSuccess
    getUser()
      .onSuccess(user -> {
        login(user).onSuccess(status -> {
          showDashboard(status).onSuccess(dashboard -> {
          }).onFailure(dashboardErr -> {
            System.out.println(dashboardErr.getMessage());
          });
        }).onFailure(loginErr -> {
          System.out.println(loginErr.getMessage());
        });
      }).onFailure(err -> {
        System.out.println(err.getMessage());
      });
  }

  //  private void giveSolutionTwo() {
//    getUser()
//      .compose(user -> {
//        return login(user);
//      })
//      .compose(status -> {
//        return showDashboard(status);
//      })
//      .onSuccess(res -> System.out.println(res))
//      .onFailure(err -> System.out.println(err));
//  }
//  private void giveSolutionTwo() {
//    getUser()
//      .compose(user -> login(user))
//      .compose(status -> showDashboard(status))
//      .onSuccess(res -> System.out.println(res))
//      .onFailure(err -> System.out.println(err));
//  }

  private void giveSolutionTwo() {
    getUser()
      .compose(this::login)
      .compose(this::showDashboard)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
     }

  @Override
  public void start() throws Exception {
    super.start();
    //giveSolutionOne();
    giveSolutionTwo();
  }

  @Override
  public void stop() throws Exception {
    super.stop();
  }
}

Callback Chaining:

1.using onComplete with handler
2.using OnSuccess and OnFailure
3.Using compose method
   ->using normal compose
   ->using lambdba 
   ->using method reference
.....................................................................................
			Future Coordination
....................................................................................
Coordination of multiple futures can be achived with "Vert.x" Futures.It supoorts concurrent composition (run several async operations in parale) and sequentional composition(chain asyn operations)

Lets i have i have three methods

1.startDbServer
2.startHttpServer
3.startConfigServer

I need to ensure that my app must initalized only, all servers are up, if any one server is failed, stop all servers , dont initalize my app.


Future Coordintation:

   Coordination of multiple futures can be achived with Vertx Futures

Vertx supports cocurrent compostion(running serveral async operations in parall) and code looks sequentail - chaining async operations.

package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class CompositFutureVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CompositFutureVerticle.class.getName());
  }

  public Future<String> startDbServer() {
    System.out.println("DB Server started");
    return Future.succeededFuture("Db Server is Up");
  }

  public Future<String> startHttpServer() {
    System.out.println("HTTP server started");
    return Future.succeededFuture("HttpServer is Up");
  }

  public Future<String> startConfigServer() {
    System.out.println("Config Server started");
    return Future.succeededFuture("Config Server is Up");
  }

  @Override
  public void start() throws Exception {
    super.start();
    Future<String> dbServer = startDbServer();
    Future<String> webServer = startHttpServer();
    Future<String> configServer = startConfigServer();
    Future.all(dbServer, configServer, webServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All servers  up");
        //do something if all servers are up
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });

    Future.all(dbServer, configServer, webServer).onSuccess(System.out::println).onFailure(System.out::println);
  }
}
....................................................................................
			Promises
...................................................................................

If Futures are read side of async result where as Promises are "write side" of async results.

Promises are insired from java script language.

Promises are semantically meaningfull abstrcation for handling async result.

Most of the developers confuse the Java Future and Vert.x Future, in order to avoid confusion, Promises were introduced.

Promises cant be processed directly with "OnComplete/OnSuccess" api 

Promises need to converted into Future before Processing.

package com.amex.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PromiseVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PromiseVerticle.class.getName());
  }

  public Promise<String> getHelloPromise() {
    Promise promise = Promise.promise();
    promise.complete("Hello Promise");
    return promise;
  }

  public Future<String> getHaiPromise() {
    Promise promise = Promise.promise();
    promise.complete("Hai Promise");
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    getHelloPromise().future().onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      }
    });
    getHelloPromise().future().onSuccess(System.out::println);

    getHaiPromise().onSuccess(System.out::println);
  }
}
.....................................................................................
		  Asynchronous Verticle Start and Stop
.....................................................................................

Sometimes you want to do something in your verticle start up which takes some time and you dont want the verticle to be considerd deployed until that happens.
For eg you might want to start an HTTP server in the method and propagate the async result of the server listen method.

You cant block waiting for the HTTP server to bind in your start method as that would break the non blocking rule.

so how can you do this?

The way to do it is to implement the async start method.
This version of the method takes a Future(Promise) as a Parameter.When the method returns the verticle will not be considered deployed.

package com.amex.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;

public class PromiseStartVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PromiseStartVerticle.class.getName());
  }

  private HttpServer httpServer;

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
  //  super.start(startPromise);
    httpServer = vertx.createHttpServer().requestHandler(req -> {
      req.response().end("Hello");
    });
    //listener
    httpServer.listen(8080, (res) -> {
      if (res.succeeded()) {
        //once this code reaches this verticle considered deployed
        startPromise.complete();
        //startPromise.fail("est");
      } else {
        startPromise.fail(res.cause());
      }
    });

  }
}
.....................................................................................
			Data Format in vertx
.....................................................................................
1.Buffer
2.JSON object

Buffer:
  Most data is shuffled around inside vertx using buffers.

 A buffer is a sequence of zero or more bytes that can read from or written to and which expands automatically as necessary to accommodate any bytes written to it.
You can perhaps think of a buffer as smart byte array.


1.Verticles running in vertx often need to process blocks of data.
2.For instance , data from an incomming http request, data loaded from the disk or data generated as response to http request etc.
3.A Buffer in vertx can hold binary data.
4.Buffer is similar to byte array, except the buffer can expand its capacity dynamically  as you write data to it.

How to create buffer?

Empty Buffer
Buffer buffer= Buffer.buffer()

Buffer from string:

Buffer buffer =Buffer.buffer("some buffer")

Buffer buffer =Buffer.buffer("some buffer","UTF-8")

Buffer from byte Array:
byte[] bytes= new Byte[] {3,6,30};
Buffer buffer=Buffer.buffer(bytes)

package com.amex.dataformats;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;

public class BufferVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run",BufferVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //create buffer object
    Buffer buffer = Buffer.buffer("hello");
    //add more data into buffer
    buffer.appendString("welcome");
    System.out.println(buffer);
  }
}
/////////////////////////////////////////////////////////////////////////////////////
			  JSON Object

package com.amex.dataformats;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;

public class JsonVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JsonVerticle.class.getName());
  }

  //simple json object
  private void createSimpleJson() {
    JsonObject profile = new JsonObject();
    //adding properties
    profile.put("id", 1);
    profile.put("name", "Subramanian");
    profile.put("status", true);
    System.out.println("Id : " + profile.getString("id"));
    System.out.println("Name : " + profile.getString("name"));
    System.out.println("Status : " + profile.getString("status"));
    int id = profile.getInteger("id");
    String name = profile.getString("name");
    boolean status = profile.getBoolean("status");
    System.out.println(id + " " + name + "" + status);
    //key value pair in json format
    System.out.println(profile.encodePrettily());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    createSimpleJson();
  }
}
....................................................................................
			Are you fluent?


A fluent API is where multiple methods calls can be chained together - Based Builder/Command Chain pattern.

Best eg:
  strings

 "hello".toString().toUpperCase().trim()

Most of the vertx apis are fluent api, so recommended to use fluent api style.


package com.amex.dataformats;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;

public class JsonVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JsonVerticle.class.getName());
  }

  //simple json object
  private void createSimpleJson() {
    JsonObject profile = new JsonObject();
    //adding properties
    profile.put("id", 1);
    profile.put("name", "Subramanian");
    profile.put("status", true);
    System.out.println("Id : " + profile.getString("id"));
    System.out.println("Name : " + profile.getString("name"));
    System.out.println("Status : " + profile.getString("status"));
    int id = profile.getInteger("id");
    String name = profile.getString("name");
    boolean status = profile.getBoolean("status");
    System.out.println(id + " " + name + "" + status);
    //key value pair in json format
    System.out.println(profile.encodePrettily());
  }

  private void createFluentJson() {
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true);
    System.out.println(profile.encodePrettily());
  }

  //nested json
  private void createNestedJson() {
    JsonObject profile = new JsonObject().put("id", 1).put("name", "Subramanian").put("status", true).put("address", new JsonObject().put("street", "10th street").put("city", "Coimbatore"));
    System.out.println(profile.encodePrettily());
  }

  //Array of json
  private void createJsonArray() {
    JsonObject profile = new JsonObject().put("id", 1).put("name", "Subramanian").put("status", true).put("address", new JsonObject().put("street", "10th street").put("city", "Coimbatore"));
    JsonArray profiles = new JsonArray()
      .add(profile)
      .add(new JsonObject().put("id", 2).put("name", "Murugan").put("status", false).put("address", new JsonObject().put("street", "8th street").put("city", "Chennai")));
    System.out.println(profiles.encodePrettily());
  }

  private void mergeJson(JsonObject jsonObject) {
    JsonObject config = new JsonObject().put("http.port", 8080).mergeIn(jsonObject);
    System.out.println(config.encodePrettily());
  }

  public Future<JsonObject> getJsonFuture() {
    JsonObject profile = new JsonObject().put("id", 1).put("name", "Subramanian").put("status", true).put("address", new JsonObject().put("street", "10th street").put("city", "Coimbatore"));
    return Future.succeededFuture(profile);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    // createSimpleJson();
    //createFluentJson();
    //createNestedJson();
    // createJsonArray();
    //mergeJson(new JsonObject().put("host", "localhost").put("ssl", true));
    getJsonFuture().onSuccess(json -> {
      System.out.println(json.encodePrettily());
    });
  }
}
.....................................................................................
.....................................................................................	
			 Building Non blocking or Async apps
.....................................................................................

in order to build non blocking io apps (network,filesystem) and timers, language or framework/lib/toolkit has to provide basic requirment.

1.Runtime should have faciltity to talk to low level operating system non blocking apis such as "select/poll/epoll-linux, iocp-windows,kqueue-mac,unix".

2.For Application developers , the language or framework/lib/toolkit must provide high level apis in order to communicate low level system calls api - vertx provides high level apis.

3.At runtime level, Runtime must provide threading features to listen for os kernal events. Event loop threads.

4.Program level, we must bind function to handle such events(callbacks)

Vertx non blocking apis:
.......................

1.Timer 
2.File System
3.Http Api
4.Socket api
5.Udp and DataGram 
etc....

.....................................................................................
				Timer
........................................................................

It is common in vertx to want to perform some action after a certain delay or perdically.

Timer is special non blocking api which schdules any task in delayed manner which does not block the current thread.

Task is executed by "CPU" level.

Timer is not part of FileDecriptor table because it is not an IO operation.


Types of timers:
1.one-shot timers
2.Periodic timers.

one-shot Timers:
 once timeout occured, the cpu emits event , and it closes the flow.

package com.amex.async.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class OneShortTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", OneShortTimerVerticle.class.getName());
  }

  private void blockMe(String message) {
    System.out.println(message);
  }

  private void delay() {
    //async
    vertx.setTimer(5000, handler -> {
      //this code to be executed after 5000ms
      System.out.println("I am delayed Task");
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    blockMe("start");
    delay();
    blockMe("stop");
  }
}
...................................................................................
		 How to transfer data with Timer to the caller
...................................................................................
package com.amex.async.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;


public class TimerWIthDataVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", TimerWIthDataVerticle.class.getName());
  }

  private void blockMe(String message) {
    System.out.println(message);
  }

  private Future<JsonObject> delay() {
    //async
    //Return Future object with data after 5000ms
    return Future.future(ar -> {
      JsonObject jsonObject = new JsonObject().put("message", "Hello");
      vertx.setTimer(5000, handler -> {
        //call future complete
        ar.complete(jsonObject);
      });
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    blockMe("start");
    delay().onSuccess(jsonObject -> {
      System.out.println(jsonObject.encodePrettily());
    });
    blockMe("stop");
  }
}
.....................................................................................
		 Passing data using callback pattern - Higher Order function
.....................................................................................

Passing function as parameter.

package com.amex.async.timers;

import io.vertx.core.*;
import io.vertx.core.json.JsonObject;


public class TimerWithHigherOrderVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", TimerWithHigherOrderVerticle.class.getName());
  }

  private void blockMe(String message) {
    System.out.println(message);
  }

  //Higher order function syntax:
  private void getMessage(Handler<AsyncResult<JsonObject>> aHandler) {
    vertx.setTimer(5000, handler -> {
      //send json object with Future
      JsonObject jsonObject = new JsonObject().put("message", "Hello");
      aHandler.handle(Future.succeededFuture(jsonObject));
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    blockMe("start");
    getMessage(response -> {
      System.out.println(response.result().encodePrettily());
    });
    blockMe("stop");
  }
}
.....................................................................................
			   Periodic Timers
.....................................................................................

Periodic timers are getting executed after time infinitely until we stop.


Simple Periodic Timer:
package com.amex.async.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PeriodicTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerVerticle.class.getName());
  }

  private void tick() {
    vertx.setPeriodic(1000, handler -> {
      System.out.println(Math.random());
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    tick();
  }
}
.....................................................................................
		   How to return Data from the Periodic Timer
....................................................................................

package com.amex.async.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;


public class PeriodicTimerWithDataVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerWithDataVerticle.class.getName());
  }

  private Future<JsonObject> poll() {
    return Future.future(ar -> {
      JsonObject jsonObject = new JsonObject().put("random", Math.random());
      vertx.setPeriodic(5000, handler -> {
        ar.complete(jsonObject);
      });
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    poll().onSuccess(res -> {
      System.out.println(res.encodePrettily());
    });
  }
}

Result:
{
  "random" : 0.11410139186857493
}
Oct 29, 2024 11:38:57 AM io.vertx.core.impl.ContextImpl
SEVERE: Unhandled exception
java.lang.IllegalStateException: Result is already complete


Here we got result one time, after that we got exception, because the future is already returned, again that method will not be called.

Solution:
 Using higher order syntax.

package com.amex.async.timers;

import io.vertx.core.*;
import io.vertx.core.json.JsonObject;


public class PeriodicTimerWithDataVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerWithDataVerticle.class.getName());
  }

  //  private Future<JsonObject> poll() {
//    return Future.future(ar -> {
//      JsonObject jsonObject = new JsonObject().put("random", Math.random());
//      vertx.setPeriodic(5000, handler -> {
//        ar.complete(jsonObject);
//      });
//    });
//  }
  private void poll(Handler<AsyncResult<JsonObject>> aHandler) {
    vertx.setPeriodic(5000, handler -> {
      JsonObject jsonObject = new JsonObject().put("random", Math.random());
      aHandler.handle(Future.succeededFuture(jsonObject));
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
//    poll().onSuccess(res -> {
//      System.out.println(res.encodePrettily());
//    });
    poll(res -> {
      System.out.println(res.result().encodePrettily());
    });
  }
}













